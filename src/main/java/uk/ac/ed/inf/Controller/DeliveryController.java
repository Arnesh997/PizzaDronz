package uk.ac.ed.inf.Controller;import uk.ac.ed.inf.Client.RestClient;import uk.ac.ed.inf.Handler.MainOrderValidation;import uk.ac.ed.inf.Model.DroneMove;import uk.ac.ed.inf.Model.Node;import uk.ac.ed.inf.Pathfinding.AStarPathFinder;import uk.ac.ed.inf.ilp.constant.OrderStatus;import uk.ac.ed.inf.ilp.data.*;import java.time.LocalDate;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;/*** DeliveryController class is the main controller class for the project. It executes the independent function and creates the necessary files.*/public class DeliveryController {    // Restaurants, noFlyZones, centralArea and Orders retrieved from the REST server    private  final Restaurant[] restaurants;    private  final List<NamedRegion> noFlyZones;    private  final NamedRegion centralArea;    private  final List<Order> orders;    private  final LocalDate date;    private  final HashMap<String,LngLat> pizzaLocationMap= new HashMap<>();    private  HashMap<LngLat, List<DroneMove>> pathCache;    private  final DroneDeliveryRecorder droneDeliveryRecorder;    private  List<Order> validOrdersToday;    // LngLat that will be used to represent the location of Appleton Tower (remains constant)    private  final LngLat appletonTower = new LngLat(-3.186874, 55.944494);;    /**     * Constructor for DeliveryController: Retrieves necessary data from the REST server     * Both parameters are assumed to be valid and in the correct format     * @param date to be passed in by a command line argument (in the format yyyy-MM-dd)     * @param BASE_URL also to be passed in by a command line argument    */    public DeliveryController(LocalDate date, String BASE_URL){        this.date = date;        RestClient restClient = new RestClient(BASE_URL);        this.restaurants = restClient.getRestaurants();        this.noFlyZones = restClient.getNoFlyZones();        this.centralArea = restClient.getCentralArea();        this.orders = restClient.getOrders(date.toString());        // Creating a map of pizza name to location to be used in path-finding        for(Restaurant restaurant: restaurants){            for(Pizza pizza: restaurant.menu()){                pizzaLocationMap.put(pizza.name(),restaurant.location());            }        }        this.pathCache = new HashMap<>();        this.droneDeliveryRecorder = new DroneDeliveryRecorder(this.date);    }    /**     * Executing the required methods to complete A*pathfinding and order delivery     */    public void run(){        if (!this.orders.isEmpty()) {            this.handleOrders();            this.handlePathFinding();        }    }    /**     * Handles the orders retrieved from the REST server by checking their validity using MainOrderValidations' validateOrder()     * and creating the necessary files     */    private void handleOrders() {        List<Order> allOrdersToday = checkOrdersAll(this.orders);        System.out.println("Total orders today: " + allOrdersToday.size());        validOrdersToday = checkOrders(this.orders);        System.out.println("Valid orders today: " + validOrdersToday.size());        // Resetting status code of all valid orders        for(Order order: validOrdersToday){            order.setOrderStatus(OrderStatus.DELIVERED);        }        droneDeliveryRecorder.createDeliveriesFile(allOrdersToday);    }    /**     * Uses the appropriate classes to handle the path-finding by creating an AStarPathFinder object and calling its findPath() method     * The path is then converted to a list of DroneMoves and passed to the DroneDeliveryRecorder object to create the necessary files     */    private void handlePathFinding() {        // Creating a AStarPathFinder object        AStarPathFinder pathController = new AStarPathFinder(this.restaurants, this.noFlyZones, this.centralArea);        List<List<DroneMove>> combinedDroneMovesPath = new ArrayList<>();        // Finding the optimal path for each valid order on the specified date        for(Order order : validOrdersToday) {            LngLat restaurantLocation = pizzaLocationMap.get(order.getPizzasInOrder()[0].name());            // Checking if the complete path has already been found and stored in the cache            if (pathCache.containsKey(restaurantLocation)) {                combinedDroneMovesPath.add(pathCache.get(restaurantLocation));                System.out.println("Path found in cache");                continue;            } else {                // Finding the path from Appleton Tower to the restaurant                List<Node> pathAppletonRestaurant = pathController.findPath(appletonTower, restaurantLocation);                pathAppletonRestaurant.add(new Node(pathAppletonRestaurant.get(pathAppletonRestaurant.size() - 1), pathAppletonRestaurant.get(pathAppletonRestaurant.size() - 1).getLocation(), 0, 0, 999.0));                // Creating a reversed path for the return journey                List<Node> pathRestaurantAppleton = new ArrayList<>(pathAppletonRestaurant);                Collections.reverse(pathRestaurantAppleton);                // Removing the last node from the path to avoid duplicates during for return journey                pathRestaurantAppleton.remove(0);                pathRestaurantAppleton.add(new Node(pathRestaurantAppleton.get(pathRestaurantAppleton.size() - 1), pathRestaurantAppleton.get(pathRestaurantAppleton.size() - 1).getLocation(), 0, 0, 999.0));                // Reversing the angles for the return path from the restaurant to Appleton Tower                for (Node node : pathRestaurantAppleton) {                    double reversedAngle = (node.getAngle() + 180) % 360;                    node.setAngle(reversedAngle);                }                // Combining the two node paths to create a complete path from Appleton Tower to the restaurant and back                List<Node> combinedNodePath = new ArrayList<>(pathAppletonRestaurant);                combinedNodePath.addAll(pathRestaurantAppleton);                // Converting Nodes in the final path to drone moves                combinedDroneMovesPath.add(convertNodesToMoves(combinedNodePath, order.getOrderNo()));                // Adding the final DroneMove path to the cache                pathCache.put(restaurantLocation, convertNodesToMoves(combinedNodePath, order.getOrderNo()));            }        }        droneDeliveryRecorder.createFlightPathFile(combinedDroneMovesPath);        droneDeliveryRecorder.createGeoJsonFile(combinedDroneMovesPath);    }    /**     * Checks all orders for validity and sets the status code of invalid orders to VALID_BUT_NOT_DELIVERED     * @param orders list of orders to be checked     * @return list of all orders with their status codes updated     */    private List<Order> checkOrdersAll(List<Order> orders){        List<Order> allOrders = new ArrayList<>();        MainOrderValidation orderValidator = new MainOrderValidation();        for(Order order: orders){            Order checkedOrder = orderValidator.validateOrder(order, this.restaurants);            if (checkedOrder.getOrderStatus() == OrderStatus.VALID_BUT_NOT_DELIVERED) {                checkedOrder.setOrderStatus(OrderStatus.DELIVERED); // Only add valid orders to the new list            }            allOrders.add(checkedOrder);        }        return allOrders;    }    /**     * Checks all orders for validity and stores only the valid orders in a new list     * @param orders list of orders to be checked     * @return list of valid orders     */    private List<Order> checkOrders(List<Order> orders) {        List<Order> validOrders = new ArrayList<>();        MainOrderValidation orderValidator = new MainOrderValidation();        for (Order order : orders) {            Order checkedOrder = orderValidator.validateOrder(order, this.restaurants);            if (checkedOrder.getOrderStatus() == OrderStatus.VALID_BUT_NOT_DELIVERED) {                validOrders.add(order); // Only add valid orders to the new list            }        }        return validOrders;    }    /**     * Converts a list of Nodes in the final path, to a list of DroneMoves     * @param path list of Nodes to be converted     * @param orderNo order number of the order to be delivered     * @return list of DroneMoves     */    private List<DroneMove> convertNodesToMoves(List<Node> path, String orderNo) {        List<DroneMove> moves = new ArrayList<>();        for (int i = 0; i < path.size() - 1; i++) {            Node start = path.get(i);            Node end = path.get(i + 1);            double angle = start.getAngle();            // Creating a new DroneMove object for each pair of nodes            DroneMove move = new DroneMove(orderNo, start.getLocation().lng(),                    start.getLocation().lat(), angle,                    end.getLocation().lng(), end.getLocation().lat());            moves.add(move);        }        // Adding a final DroneMove to the list to represent the drone hovering at Appleton Tower        moves.add(new DroneMove(orderNo, appletonTower.lng(),                appletonTower.lat(), 999.0,                appletonTower.lng(),                appletonTower.lat()));        return moves;    }}