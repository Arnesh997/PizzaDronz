package uk.ac.ed.inf;import uk.ac.ed.inf.ilp.data.LngLat;import uk.ac.ed.inf.ilp.data.NamedRegion;import uk.ac.ed.inf.ilp.data.Order;import uk.ac.ed.inf.ilp.data.Restaurant;import java.util.*;public class AStarPathControl {    private NamedRegion centralArea;    private List<NamedRegion> noFlyZones;    private Restaurant[] restaurants;    private Order order;    private LngLat endPosition;    MainLngLatHandle lngLatHandle = new MainLngLatHandle();    public AStarPathControl(Restaurant[] restaurants, List<NamedRegion> noFlyZones, NamedRegion centralArea) {        this.restaurants = restaurants;        this.noFlyZones = noFlyZones;        this.centralArea = centralArea;        this.endPosition = new LngLat(-3.1869, 55.9445);    }    public  List<Node> findPath(LngLat start) {        Node startNode = new Node(null, start, 0, lngLatHandle.distanceTo(start, endPosition));        startNode.setfCost(startNode.getHCost() + startNode.getGCost());        PriorityQueue<Node> openSet = new PriorityQueue<>(Comparator.comparingDouble(Node::getFCost));        Set<LngLat> closedSet = new HashSet<>();        openSet.add(startNode);        System.out.println("Start node: "+startNode);        while (!openSet.isEmpty()) {            Node currentNode = openSet.poll();            System.out.println("Current Position: "+currentNode.getLocation());            System.out.println("End position: "+endPosition);            if (lngLatHandle.isCloseTo(currentNode.getLocation(),endPosition)) {                return constructPath(currentNode);            }            closedSet.add(currentNode.getLocation());            List<Node> neighbors = getNeighbors(currentNode);            for (Node neighbor : neighbors) {                if (closedSet.contains(neighbor.getLocation())) {                    continue;                }                double tentativeGCost = currentNode.getGCost() + getDistance(currentNode, neighbor);                if (tentativeGCost < neighbor.getGCost()) {                    neighbor.setParent(currentNode);                    neighbor.setgCost(tentativeGCost);                    neighbor.setfCost(tentativeGCost + neighbor.getHCost());                    if (openSet.stream().noneMatch(n -> n.getLocation().equals(neighbor.getLocation()))) {                        openSet.add(neighbor);                    }                }            }        }        return new ArrayList<>(); // Return an empty path if there is no path from start to end    }    private List<Node> constructPath(Node lastNode) {        List<Node> path = new ArrayList<>();        Node currentNode = lastNode;        double totalGCost = 0;        while (currentNode != null) {            path.add(0, currentNode); // Add to the beginning of the list to avoid reversing later            totalGCost = currentNode.getGCost();            currentNode = currentNode.getParent();        }        // Add the end node with the correct gCost (total cost to reach this node)        Node endNode = new Node(lastNode, endPosition, totalGCost, 0);        path.add(endNode);        return path;    }//    private List<Node> getNeighbors(Node node) {//        List<Node> neighbors = new ArrayList<>();//        // Define the angles for possible movements//        double[] angles = {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5, 180, 202.5, 225, 247.5, 270, 292.5, 315, 337.5, 360};////        // Get the current location//        LngLat currentLocation = node.getLocation();////        // Check if current position is within the central area//        boolean currPosInCentral = lngLatHandle.isInCentralArea(currentLocation, centralArea);////        for (double angle : angles) {//            LngLat nextPos = lngLatHandle.nextPosition(currentLocation, angle);//            System.out.println("Next position: "+nextPos);//            // Check against all no-fly zones////            boolean validPosition = true;////            for (NamedRegion noFlyZone : noFlyZones) { // assuming noFlyZones is a List<NamedRegion>////                if (lngLatHandle.isInRegion(nextPos, noFlyZone)) {////                    validPosition = false;////                    break;////                }////            }////            // Add the position as a neighbor only if it's not in any no-fly zone and it's in the same region as the current position////            if (validPosition && (currPosInCentral == lngLatHandle.isInCentralArea(nextPos, centralArea))) {////                double gCost = node.getGCost() + lngLatHandle.distanceTo(currentLocation, nextPos);////                double hCost = calculateHeuristic(nextPos, endPosition);////////                Node neighbor = new Node(node, nextPos, gCost, hCost, gCost + hCost);////                neighbors.add(neighbor);////            }////            double gCost = node.getGCost() + lngLatHandle.distanceTo(currentLocation, nextPos);//            double hCost = calculateHeuristic(nextPos, endPosition);////            Node neighbor = new Node(node, nextPos, gCost, hCost, gCost + hCost);//            neighbors.add(neighbor);//        }//        System.out.println("Neighbors: "+neighbors);//        return neighbors;//    }//      New getNeighbors method    public List<Node> getNeighbors(Node currNode){        List<Node> neighbors = new ArrayList<>();        boolean currPosInCentral = lngLatHandle.isInRegion(currNode.getLocation(), centralArea);        double[] angles = {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5, 180, 202.5, 225, 247.5, 270, 292.5, 315, 337.5, 360};        System.out.println("No Fly Zones in getNeighbors: "+noFlyZones);        for(Double angle: angles){            LngLat nextPos = lngLatHandle.nextPosition(currNode.getLocation(), angle);            boolean isNextPosInCentral = lngLatHandle.isInRegion(nextPos, centralArea);            boolean isValid = true;            if(!currPosInCentral && isNextPosInCentral){                continue;            }            for(NamedRegion noFlyZone: noFlyZones){                System.out.println("No Fly Zone for first termination: "+noFlyZone);                if(lngLatHandle.isInRegion(nextPos, noFlyZone)){                    isValid = false;                    break;                }            }            if(isValid){                Node nextNode = new Node(currNode, nextPos, currNode.getGCost() + lngLatHandle.distanceTo(currNode.getLocation(),nextPos), lngLatHandle.distanceTo(nextPos, endPosition));                neighbors.add(nextNode);            }        }        return neighbors;    }    // Define the method to get the distance between two nodes    private  double getDistance(Node node1, Node node2) {        return lngLatHandle.distanceTo(node1.getLocation(),node2.getLocation());    }//  Heuristic function for A* search. This is the Euclidean distance between the current node and the end node.    private  double calculateHeuristic(LngLat point, LngLat end) {        return lngLatHandle.distanceTo(point, end);    }}