package uk.ac.ed.inf;import uk.ac.ed.inf.ilp.constant.OrderStatus;import uk.ac.ed.inf.ilp.constant.OrderValidationCode;import uk.ac.ed.inf.ilp.constant.SystemConstants;import uk.ac.ed.inf.ilp.data.Order;import uk.ac.ed.inf.ilp.data.Pizza;import uk.ac.ed.inf.ilp.data.Restaurant;import uk.ac.ed.inf.ilp.interfaces.OrderValidation;import java.time.DayOfWeek;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.YearMonth;import java.time.format.DateTimeFormatter;import java.util.HashMap;import java.util.HashSet;import java.util.Set;import static uk.ac.ed.inf.ilp.constant.SystemConstants.MAX_PIZZAS_PER_ORDER;//Things to Validate:// 1. Number of pizzas in the order// 2. Credit card info - Expiry Date// 3. Restaurant - Opening Days with the order date// 4. Total Price in Pence: Note - 100pence added for delivery for all orders// 5. Past Orders are not to be considered// 6. You have to check card number, expiration, order date and items among other details (as described in this document)// 7. All items in an order must come from the same pizza restaurant and are valid pizzas// 8. Total Price validation. (Price +100pence for delivery), Total > 0// 9. Validate past and future order datepublic class MainOrderValidation implements OrderValidation{    static HashMap<String,String> pizzaRestaurantMap;    static HashMap<String, HashSet<DayOfWeek>> restaurantOpeningDaysMap;    @Override    public Order validateOrder(Order orderToValidate, Restaurant[] definedRestaurants) {        // Variables for the orderToValidate        Pizza[] pizzasInOrder = orderToValidate.getPizzasInOrder();        LocalDate orderDate = orderToValidate.getOrderDate();        int totalPrice = orderToValidate.getPriceTotalInPence();        // Variables for credit card validation        String creditCardNumber = orderToValidate.getCreditCardInformation().getCreditCardNumber();        String creditCardExpiryDate = orderToValidate.getCreditCardInformation().getCreditCardExpiry();        String creditCvv = orderToValidate.getCreditCardInformation().getCvv();//      NUMBER OF PIZZAS in the order check        boolean pizzaCountCheck = pizzasInOrder.length <= MAX_PIZZAS_PER_ORDER;//      Credit Card Validation        boolean checkCardNumber = cardNumberCheck(creditCardNumber);        boolean checkCardExpiry = cardExpiryCheck(creditCardExpiryDate);        boolean checkCardCvv = cardCvvCheck(creditCvv);//      Total Price in Pence Validation        boolean totalPriceValidation = totalPriceCheck(pizzasInOrder, totalPrice);//      PIZZA_NOT_DEFINED & PIZZA_FROM_MULTIPLE_RESTAURANTS in the order check//      Using a hashmap to map the pizza name to the restaurant name//      If the pizza name is not in the hashmap, then the pizza is not defined//      If ordered pizzas match with multiple restaurants, then PIZZA_FROM_MULTIPLE_RESTAURANTS        boolean pizzaDefined = false;        boolean pizzaFromMultipleRestaurants = false;        pizzaRestaurantMap = new HashMap<>();        for(Restaurant rest : definedRestaurants) {            for(Pizza pizza: rest.menu()){                pizzaRestaurantMap.put(pizza.name(), rest.name());            }        }        pizzaDefined = pizzaDefineCheck(pizzasInOrder);        pizzaFromMultipleRestaurants = pizzaMultipleRestaurantsCheck(pizzasInOrder);//       RESTAURANT_CLOSED on the order date check//       Using a hashmap to map the restaurant name to the opening days        restaurantOpeningDaysMap = new HashMap<>();        for(Restaurant rest: definedRestaurants ){            Set<DayOfWeek> openingDays = new HashSet<>();            for(DayOfWeek day: rest.openingDays()){                openingDays.add(day);            }            restaurantOpeningDaysMap.put(rest.name(), (HashSet<DayOfWeek>) openingDays);        }        boolean restaurantClosed = restaurantClosedCheck(orderDate);//      ORDER DATE CHECKS//      Past Order date check - Required for validation code DELIVERED and along with credit card validation        boolean pastOrderDate = pastOrderDateCheck(orderDate);//      Future Order date check  - Required for validation code INVALID        boolean futureOrderDate = futureOrderDateCheck(orderDate);//      Current Order date check - Required for validation code VALID_BUT_NOT_DELIVERED        boolean currentOrderDate = currentOrderDateCheck(orderDate);        // Add other validations here, like validating the credit card info, checking the restaurant, etc.        // If all validations pass, set the order as valid        orderToValidate.setOrderStatus(OrderStatus.VALID_BUT_NOT_DELIVERED);        orderToValidate.setOrderValidationCode(OrderValidationCode.NO_ERROR);        return orderToValidate;    }    boolean currentOrderDateCheck(LocalDate orderDate){        LocalDate currentDate = LocalDate.now();        return orderDate.isEqual(currentDate);    }    boolean futureOrderDateCheck(LocalDate orderDate){        LocalDate currentDate = LocalDate.now();        return orderDate.isAfter(currentDate);    }    boolean pastOrderDateCheck(LocalDate orderDate){        LocalDate currentDate = LocalDate.now();        return orderDate.isBefore(currentDate);    }    boolean restaurantClosedCheck(LocalDate orderDate){        String restaurantName = "";        for(String pizzaName: pizzaRestaurantMap.keySet()){            restaurantName = pizzaRestaurantMap.get(pizzaName);        }        HashSet<DayOfWeek> openingDays = restaurantOpeningDaysMap.get(restaurantName);        if(openingDays.contains(orderDate.getDayOfWeek())){            return false;        }        else{            return true;        }    }    boolean pizzaDefineCheck(Pizza[] pizzasInOrder){        int count = 0;        for(Pizza pizza: pizzasInOrder){            if(pizzaRestaurantMap.containsKey(pizza.name())){                count++;            }        }        return count == pizzasInOrder.length;    }    boolean pizzaMultipleRestaurantsCheck(Pizza[] pizzasInOrder){        HashSet<String> restaurantSet = new HashSet<>();        for(Pizza pizza: pizzasInOrder){            restaurantSet.add(pizzaRestaurantMap.get(pizza.name()));        }        if(restaurantSet.size() > 1){            return true;        }        else {            return false;        }    }    boolean totalPriceCheck(Pizza[] pizzasInOrder, int totalPrice){        int priceTotal = 0;        for (Pizza pizza : pizzasInOrder) {            priceTotal += pizza.priceInPence();        }        return ((priceTotal > 0) && (priceTotal+100 == totalPrice));    }//  Card Number Check: Length and Luhn Algorithm check    boolean cardNumberCheck(String cardNumber){        if (cardNumber == null || cardNumber.length() != 16) {            return false;        }        if (!cardNumber.matches("\\d+")) { // checks if the card number contains only digits            return false;        }        return true;    }//    Card CVV check    boolean cardCvvCheck(String cardCvv){        if (cardCvv == null || cardCvv.length() != 3) {            return false;        }        if (!cardCvv.matches("\\d+")) { // checks if the card number contains only digits            return false;        }        return true;    }//    Card Expiry Check    boolean cardExpiryCheck(String cardExpiryDate){        // Check if expiryDate is not null        if (cardExpiryDate == null) {            return false;        }        // Parse the expiry date        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/yy");        YearMonth expDate;        try {            expDate = YearMonth.parse(cardExpiryDate, formatter);        } catch (Exception e) {            return false;        }        // Compare the expiry year and month with the current year and month        return !YearMonth.now().isAfter(expDate);    }}