package uk.ac.ed.inf;import uk.ac.ed.inf.ilp.data.LngLat;import uk.ac.ed.inf.ilp.data.NamedRegion;import uk.ac.ed.inf.ilp.interfaces.LngLatHandling;public class MainLngLatHandle implements LngLatHandling {    @Override    public double distanceTo(LngLat startPosition, LngLat endPosition) {        double startLat = startPosition.lat();        double startLng = startPosition.lng();        double endLat = endPosition.lat();        double endLng = endPosition.lng();        double calcuLat = Math.pow((endLat - startLat), 2);        double calcuLng = Math.pow((endLng - startLng), 2);        double distance = Math.sqrt(calcuLat + calcuLng);        return distance;    }    @Override    public boolean isCloseTo(LngLat startPosition, LngLat otherPosition) {        double distance = distanceTo(startPosition, otherPosition);//        Being close to the location will be sufficient, where l1 is close to l2 if//        the distance between l1 and l2 is strictly less than the distance tolerance of 0.00015 degrees.        if (distance < 0.00015){            return true;        }        return false;    }    @Override    public boolean isInRegion(LngLat position, NamedRegion region) {        //Raycasting algorithm        String regionName = region.name();        LngLat[] regionBoundary = region.vertices();        double positionLat = position.lat();        double positionLng = position.lng();        int boundaryLength = regionBoundary.length;        int i, j;        boolean result = false;        for (i = 0, j = boundaryLength - 1; i < boundaryLength; j = i++) {            double iLat = regionBoundary[i].lat();            double iLng = regionBoundary[i].lng();            double jLat = regionBoundary[j].lat();            double jLng = regionBoundary[j].lng();            boolean condition1 = (iLat > positionLat) != (jLat > positionLat);            boolean condition2 = (positionLng < (jLng - iLng) * (positionLat - iLat) / (jLat - iLat) + iLng);            if (condition1 && condition2){                result = !result;            }        }        return false;    }    @Override    public LngLat nextPosition(LngLat startPosition, double angle) {        return null;    }}