package uk.ac.ed.inf;import uk.ac.ed.inf.ilp.data.LngLat;import uk.ac.ed.inf.ilp.data.NamedRegion;import uk.ac.ed.inf.ilp.interfaces.LngLatHandling;public class MainLngLatHandle implements LngLatHandling {    @Override    public double distanceTo(LngLat startPosition, LngLat endPosition) {        double startLat = startPosition.lat();        double startLng = startPosition.lng();        double endLat = endPosition.lat();        double endLng = endPosition.lng();        double calcuLat = Math.pow((endLat - startLat), 2);        double calcuLng = Math.pow((endLng - startLng), 2);        double distance = Math.sqrt(calcuLat + calcuLng);        return distance;    }    @Override    public boolean isCloseTo(LngLat startPosition, LngLat otherPosition) {        double distance = distanceTo(startPosition, otherPosition);//        Being close to the location will be sufficient, where l1 is close to l2 if//        the distance between l1 and l2 is strictly less than the distance tolerance of 0.00015 degrees.        if (distance < 0.00015){            return true;        }        return false;    }    @Override    public boolean isInRegion(LngLat position, NamedRegion region) {        //Raycasting algorithm        String regionName = region.name();        LngLat[] regionBoundary = region.vertices();        double positionLat = position.lat();        double positionLng = position.lng();        int boundaryLength = regionBoundary.length;        int i, j;        boolean result = false;        for (i = 0, j = boundaryLength - 1; i < boundaryLength; j = i++) {            double iLat = regionBoundary[i].lat();            double iLng = regionBoundary[i].lng();            double jLat = regionBoundary[j].lat();            double jLng = regionBoundary[j].lng();            boolean condition1 = (iLat > positionLat) != (jLat > positionLat);            // Avoid division by zero            if (jLat != iLat) {                boolean condition2 = (positionLng < (jLng - iLng) * (positionLat - iLat) / (jLat - iLat) + iLng);                if (condition1 && condition2) {                    result = !result;                }            }        }        return result;    }    @Override    public LngLat nextPosition(LngLat startPosition, double angle) {//  the drone cannot fly in an arbitrary direction: it can only fly in one of the 16 major compass directions as seen in Figure 1. These are the primary directions North, South, East and West, and the secondary directions between those of North East, North West, South East and South West, and the tertiary directions between those of North North East, East North East, and so forth. We use the convention that 0 means go East, 90 means go North, 180 means go West, and 270 means go South, with the secondary and tertiary compass directions representing the obvious directions between these four major compass directions. The convention that we use for angles simplifies the calculation of the next position of the drone.//  The drone can fly at a constant speed of 18 km/h, and consumes power at a constant rate of 1% per km. The drone can hover in place, consuming no power, and can do so for as long as it wants. The drone is launched each day from the top of the Appleton Tower at location (−3.186874, 55.944494) and should return close to this location before running out of battery energy.//• as the drone flies, it travels at a constant speed and consumes power at a constant rate;//• when the drone is hovering, we use 9998 (only needed inside JSON files) as the reference value for the angle, to indicate that the angle does not play a role in determining the next latitude and longitude of the drone;//• the drone must hover for one move when collecting a pizza order from a restaurant, and do the same when delivering pizzas to the roof of the Appleton Tower;//• the drone is launched each day from the top of the Appleton Tower at location (−3.186874, 55.944494) and should return close to this location before running out of battery energy.//• Every valid (you have to check that) order for a day has to be delivered in exactly the order it was returned by the web-service to make sure that people are not prioritized and get their food as wanted.        double startLat = startPosition.lat();        double startLng = startPosition.lng();        double nextLat = startLat;        double nextLng = startLng;        double angleInRadian = Math.toRadians(angle);        double distance = 0.00015;        double distanceLat = distance * Math.cos(angleInRadian);        double distanceLng = distance * Math.sin(angleInRadian);        nextLat += distanceLat;        nextLng += distanceLng;        LngLat nextPosition = new LngLat(nextLng, nextLat);        return nextPosition;    }}