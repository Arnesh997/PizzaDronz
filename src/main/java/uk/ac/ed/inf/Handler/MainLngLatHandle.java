package uk.ac.ed.inf.Handler;import uk.ac.ed.inf.ilp.data.LngLat;import uk.ac.ed.inf.ilp.data.NamedRegion;import uk.ac.ed.inf.ilp.interfaces.LngLatHandling;import java.util.Arrays;import static uk.ac.ed.inf.ilp.constant.SystemConstants.DRONE_IS_CLOSE_DISTANCE;import static uk.ac.ed.inf.ilp.constant.SystemConstants.DRONE_MOVE_DISTANCE;public class MainLngLatHandle implements LngLatHandling {    /**     * get the distance between two positions     * @param startPosition is where the start is     * @param endPosition is where the end is     * @return the euclidean distance between the positions     */    @Override    public double distanceTo(LngLat startPosition, LngLat endPosition) {        double startLat = startPosition.lat();        double startLng = startPosition.lng();        double endLat = endPosition.lat();        double endLng = endPosition.lng();        double calcuLat = Math.pow((endLat - startLat), 2);        double calcuLng = Math.pow((endLng - startLng), 2);        double distance = Math.sqrt(calcuLat + calcuLng);        return distance;    }    /**     * check if two positions are close (< than SystemConstants.DRONE_IS_CLOSE_DISTANCE)     * @param startPosition is the starting position     * @param otherPosition is the position to check     * @return if the positions are close     */    @Override    public boolean isCloseTo(LngLat startPosition, LngLat otherPosition) {        double distance = distanceTo(startPosition, otherPosition);//        Being close to the location will be sufficient, where l1 is close to l2 if//        the distance between l1 and l2 is strictly less than the distance tolerance of 0.00015 degrees.        if (distance < DRONE_IS_CLOSE_DISTANCE){            return true;        }        return false;    }    /**     * check if the @position is in the @region (includes the border)     * @param position to check     * @param region as a closed polygon     * @return if the position is inside the region (including the border)     */    @Override//    public boolean isInRegion(LngLat position, NamedRegion region) {//        LngLat[] regionBoundary = region.vertices();//        int boundaryLength = regionBoundary.length;////        // Check if the point is on a vertex or an edge of the polygon//        for (int i = 0, j = boundaryLength - 1; i < boundaryLength; j = i++) {//            LngLat vi = regionBoundary[i];//            LngLat vj = regionBoundary[j];////            if (position.equals(vi) || position.equals(vj)) {//                return true; // The point is on a vertex//            }////            if (isOnSegment(vi, vj, position)) {//                return true; // The point is on an edge//            }//        }////        // Raycasting algorithm to check if the point is inside the polygon//        int intersections = 0;//        for (int i = 0, j = boundaryLength - 1; i < boundaryLength; j = i++) {//            LngLat vi = regionBoundary[i];//            LngLat vj = regionBoundary[j];////            if ((vi.lat() > position.lat()) != (vj.lat() > position.lat())) {//                double longitudeAtY = vi.lng() + (position.lat() - vi.lat()) * (vj.lng() - vi.lng()) / (vj.lat() - vi.lat());//                if (position.lng() < longitudeAtY) {//                    intersections++;//                }//            }//        }////        return (intersections % 2 == 1); // Odd number of intersections means inside//    }////    public boolean isOnSegment(LngLat vi, LngLat vj, LngLat position) {//        if (Math.min(vi.lng(), vj.lng()) <= position.lng() && position.lng() <= Math.max(vi.lng(), vj.lng()) &&//                Math.min(vi.lat(), vj.lat()) <= position.lat() && position.lat() <= Math.max(vi.lat(), vj.lat())) {////            double lineSlope = (vj.lat() - vi.lat()) / (vj.lng() - vi.lng());//            double interpolatedLatitude = lineSlope * (position.lng() - vi.lng()) + vi.lat();////            return position.lat() == interpolatedLatitude;//        }//        return false;//    }    public boolean isInRegion(LngLat position, NamedRegion region) {        int counter = 0;        LngLat[] vertices = region.vertices();        for(int i = 0;i< vertices.length ;i++){            LngLat currVertex = vertices[i];            LngLat nextVertex = vertices[(i+1)% vertices.length];            //Checking if the point is on edge            boolean pointOnEdgeCondition1 = position.lng() > Math.min(currVertex.lng(), nextVertex.lng());            boolean pointOnEdgeCondition2 = position.lng() <= Math.max(currVertex.lng(), nextVertex.lng());            if (pointOnEdgeCondition1 && pointOnEdgeCondition2) {                // Calculating the slope of the line between current and endPoint                double lineSlope = (nextVertex.lat() - currVertex.lat()) / (nextVertex.lng() - currVertex.lng());                double interpolatedLatitude = lineSlope * (position.lng() - currVertex.lng()) + currVertex.lat();                if (position.lat() == interpolatedLatitude) {                    return true;                }            }            // Checking if the point is on a vertex            if (position.lng() == currVertex.lng() && position.lat() == currVertex.lat()) {                return true;            }            boolean latitudeCheck =  position.lat() <= Math.max(nextVertex.lat(),currVertex.lat()) && position.lat() > Math.min(nextVertex.lat(),currVertex.lat());            double latitudeFraction = ((position.lat() - currVertex.lat()) / (nextVertex.lat() - currVertex.lat())) * (nextVertex.lng() - currVertex.lng());            boolean longitudeCheck = position.lng() < (currVertex.lng() + latitudeFraction);            if (longitudeCheck && latitudeCheck) {                counter++;            }        }        return counter%2 == 1;    }    /**     * find the next position if an @angle is applied to a @startPosition     * @param startPosition is where the start is     * @param angle is the angle to use in degrees     * @return the new position after the angle is used     */    @Override    public LngLat nextPosition(LngLat startPosition, double angle) {        double[] validAngles = {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5, 180, 202.5, 225, 247.5, 270, 292.5, 315, 337.5};        boolean isValidAngle = Arrays.stream(validAngles).anyMatch(a -> a == angle);        if (!isValidAngle) {            return startPosition;        }        double startLat = startPosition.lat();        double startLng = startPosition.lng();        double nextLat = startLat;        double nextLng = startLng;        double angleInRadian = Math.toRadians(angle);        double distance = DRONE_MOVE_DISTANCE;        double distanceLat = distance * Math.sin(angleInRadian);        double distanceLng = distance * Math.cos(angleInRadian);        nextLat += distanceLat;        nextLng += distanceLng;        LngLat nextPosition = new LngLat(nextLng, nextLat);        return nextPosition;    }}