package uk.ac.ed.inf.Handler;import uk.ac.ed.inf.ilp.constant.SystemConstants;import uk.ac.ed.inf.ilp.data.LngLat;import uk.ac.ed.inf.ilp.data.NamedRegion;import uk.ac.ed.inf.ilp.interfaces.LngLatHandling;import java.util.Arrays;import static uk.ac.ed.inf.ilp.constant.SystemConstants.DRONE_IS_CLOSE_DISTANCE;import static uk.ac.ed.inf.ilp.constant.SystemConstants.DRONE_MOVE_DISTANCE;public class MainLngLatHandle implements LngLatHandling {    /**     * get the distance between two positions     * @param startPosition is where the start is     * @param endPosition is where the end is     * @return the euclidean distance between the positions     */    @Override    public double distanceTo(LngLat startPosition, LngLat endPosition) {        double startLat = startPosition.lat();        double startLng = startPosition.lng();        double endLat = endPosition.lat();        double endLng = endPosition.lng();        double calcuLat = Math.pow((endLat - startLat), 2);        double calcuLng = Math.pow((endLng - startLng), 2);        double distance = Math.sqrt(calcuLat + calcuLng);        return distance;    }    /**     * check if two positions are close (< than SystemConstants.DRONE_IS_CLOSE_DISTANCE)     * @param startPosition is the starting position     * @param otherPosition is the position to check     * @return if the positions are close     */    @Override    public boolean isCloseTo(LngLat startPosition, LngLat otherPosition) {        double distance = distanceTo(startPosition, otherPosition);//        Being close to the location will be sufficient, where l1 is close to l2 if//        the distance between l1 and l2 is strictly less than the distance tolerance of 0.00015 degrees.        if (distance < DRONE_IS_CLOSE_DISTANCE){            return true;        }        return false;    }    /**     * check if the @position is in the @region (includes the border)     * @param position to check     * @param region as a closed polygon     * @return if the position is inside the region (including the border)     */    @Override    public boolean isInRegion(LngLat position, NamedRegion region) {        int counter = 0;        LngLat[] vertices = region.vertices();        for(int i = 0;i< vertices.length ;i++){            LngLat currVertex = vertices[i];            LngLat nextVertex = vertices[(i+1)% vertices.length];            //Checking if the point is on edge            if (pointOnEdge(position, currVertex, nextVertex)) {                return true;            }            // Checking if the point is on a vertex            if (position.lng() == currVertex.lng() && position.lat() == currVertex.lat()) {                return true;            }            boolean latitudeCheck =  position.lat() <= Math.max(nextVertex.lat(),currVertex.lat()) && position.lat() > Math.min(nextVertex.lat(),currVertex.lat());            double latitudeFraction = ((position.lat() - currVertex.lat()) / (nextVertex.lat() - currVertex.lat())) * (nextVertex.lng() - currVertex.lng());            boolean longitudeCheck = position.lng() < (currVertex.lng() + latitudeFraction);            if (longitudeCheck && latitudeCheck) {                counter++;            }        }        return counter%2 == 1;    }    private boolean pointOnEdge(LngLat position, LngLat currentVertex, LngLat nextVertex) {        boolean edgeCondition1 = position.lng() > Math.min(currentVertex.lng(), nextVertex.lng());        boolean edgeCondition2 = position.lng() <= Math.max(currentVertex.lng(), nextVertex.lng());        if (edgeCondition1 && edgeCondition2) {            double lineSlope = (nextVertex.lat() - currentVertex.lat()) / (nextVertex.lng() - currentVertex.lng());            double interpolatedLatitude = lineSlope * (position.lng() - currentVertex.lng()) + currentVertex.lat();            if (position.lat() == interpolatedLatitude) {                return true;            }        }        return false;    }    /**     * find the next position if an @angle is applied to a @startPosition     * @param startPosition is where the start is     * @param angle is the angle to use in degrees     * @return the new position after the angle is used     */    @Override    public LngLat nextPosition(LngLat startPosition, double angle) {        double[] validAngles = {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5, 180, 202.5, 225, 247.5, 270, 292.5, 315, 337.5};        boolean isValidAngle = Arrays.stream(validAngles).anyMatch(a -> a == angle);        if (!isValidAngle) {            return startPosition;        }        double startLat = startPosition.lat();        double startLng = startPosition.lng();        double nextLat = startLat;        double nextLng = startLng;        double angleInRadian = Math.toRadians(angle);        double distance = DRONE_MOVE_DISTANCE;        double distanceLat = distance * Math.sin(angleInRadian);        double distanceLng = distance * Math.cos(angleInRadian);        nextLat += distanceLat;        nextLng += distanceLng;        LngLat nextPosition = new LngLat(nextLng, nextLat);        return nextPosition;    }//}